# [832. 翻转图像](https://leetcode-cn.com/problems/flipping-an-image/)

给定一个二进制矩阵 `A`，我们想先水平翻转图像，然后反转图像并返回结果。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 `[1, 1, 0]` 的结果是 `[0, 1, 1]`。

反转图片的意思是图片中的 `0` 全部被 `1` 替换， `1` 全部被 `0` 替换。例如，反转 `[0, 1, 1]` 的结果是 `[1, 0, 0]`。

示例 1:

```
输入: [[1,1,0],[1,0,1],[0,0,0]]
输出: [[1,0,0],[0,1,0],[1,1,1]]
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
```


示例 2:

```
输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
```


说明:

- `1 <= A.length = A[0].length <= 20`
- `0 <= A[i][j] <= 1`

## 思路

首先，需要理解题干，翻转图像的意思是先水平翻转（逆序）再做反转图片（取反）操作，文字上可能不是那么好理解，我们来可视化一下：

（示例1）

![示例1](../img/图片1.png)

（示例2）

![示例2](../img/image-20210224094625772.png)

#### 模拟操作

根据题干描述的操作进行模拟，首先进行水平翻转，再进行反转图片。

```python
class Solution:
    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:
        for i in range(len(A)):
            A[i].reverse() # 按行逆序
        for i in range(len(A)):
            for j in range(len(A[i])):
                if A[i][j] == 1:
                    A[i][j] = 0	# 按行取反
                else:
                    A[i][j] = 1
        return A
```

![image-20210224100244661](../img/image-20210224100244661.png)

### 题解参考

#### 见缝插针

1. 对于一行的第一个数，找到它对应的数，即改行的最后一个数；
2. 如果两数不同，如一个为1一个为0，那么先10反转，即一个为0一个为1，再左右反转，又变成一个为1一个为0；
3. 两数不同时不用做任何操作；
4. 当两数相同时，要同时异或或被1减，即10反转；
5. 注意，循环的范围应该是 range(len(row) + 1) // 2)，不能忘了加一。因为，如果列数为奇数，那么中间的数虽然不要左右交换，但是10还是要反转的，因此要多一次循环，相同于中间的数与自己是相同的，要反转。


```python
class Solution:
    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:
        for row in A:
            for j in range((len(row) + 1) // 2):
                if row[j] == row[-1-j]:             # 采用Python化的符号索引
                    row[j] = row[-1-j] = 1 - row[j]    
        return A
```

##### 复杂度

- 时间复杂度 O(N)*O*(*N*)，做了一次遍历。
- 空间复杂度 O(1)*O*(1)，只用了常量空间，没有用额外的空间
- 实测效果，是最快的

#### 花样一行法

1. 运用生成器的技巧，在一行生成符合要求的列表；
2. 主要用切片、map等方法
3. 操作还是按部就班地进行翻转
4. 有多种一行写完的方法（不对异或和被1减的情况进行区分）

##### 第一种

```python
return [list(map(lambda x:1-x,row[::-1])) for row in A]
```

对每一行先翻转，再对每一行异或。其中这里的切片是完整取row然后逆序，生成新的list。

##### 第二种

```python
return [list(map(lambda x:1-x,row[::-1])) for row in A]
```

这个思路一样，只是利用了 map 和 lambda。map 是指对第二个参数的每一项执行第一个参数（函数）。相当于`map(function,list)`

等价于

```python
for x in list:
    function(x)
```

最后需要一个 list() 将 map 对象转为 list 对象
lambda 是匿名函数，就是将函数写在一行，以 lambda x:1-x 为例，就相当于

```python
def function(x):
    return 1 - x 
```

当然可以省略掉 map 和 lambda，变成

```python
return [1 - x for x in row[::-1] for row in A]
```

和第一种相同。

#### 复杂度

- 时间复杂度 O(N)O(N)，遍历一遍
- 空间复杂度 O(n)O(n)，切片是需要额外空间的，这里的 n 为行数，而不是元素总数。
- 实测效果，是中等速度的。因为虽然复杂度更大，但是用了内置函数，效率更高。所以介于方法一和方法二之间。

